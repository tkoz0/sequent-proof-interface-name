{"version":3,"sources":["utils/Constants.ts","components/Footer.tsx","components/Header.tsx","components/Menu.tsx","components/RuleSelector.tsx","utils/LogicUtils.ts","logic/ExprBase.ts","logic/ExprAnd.ts","logic/ExprAtom.ts","logic/ExprCont.ts","logic/ExprIf.ts","logic/ExprIff.ts","logic/ExprNot.ts","logic/ExprOr.ts","logic/Parser.ts","components/ProofSequent.tsx","components/ProofList.tsx","components/ParserTestButton.tsx","logic/ExprAny.ts","logic/Justification.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["ENABLE_PARSER_TEST","Footer","react_default","a","createElement","className","Header","Menu","_ref","addSequent","clearProof","loadProofFile","editing","saveProofFile","inputFile","useRef","onClick","current","click","type","style","display","accept","ref","multiple","onChange","_ref2","Object","asyncToGenerator","regenerator_default","mark","_callee","e","files","_data","wrap","_context","prev","next","target","length","Promise","resolve","reject","reader","FileReader","onload","result","toString","onabort","readAsText","data","sent","alert","err","stop","_x","apply","this","arguments","fname","prompt","endsWith","file","Blob","document","url","URL","createObjectURL","href","download","body","appendChild","setTimeout","removeChild","window","revokeObjectURL","confirm","id","match","comment","expr","expr_text","ref_by","Set","refs","rule","RuleSelector","enabled","value","setValue","disabled","REGEX_ATOM","REGEX_ATOM_START","REGEX_WHITESPACE","REGEX_NONWHITESPACE_CHAR","bpdfs","graph","i","R","seen","matchR","j","has","getSequent","calc","idCalc","get","undefined","index","indexOfSequent","idList","_getSequent3","_getSequent4","slicedToArray","tmpData","equals","indexOfSequent2","exprList","sameExprs","b","bMatched","forEach","push","v","reduce","curr","setToList","s","ret","ExprBase","values","classCallCheck","_values","ExprAnd","_super","call","map","join","toSaveString","listsEqual","ExprAtom","_this","_label","label","ExprCont","ExprIf","ExprIff","ExprNot","ExprOr","Parser","whitespace","substring","char","skipWhitespace","token","toLowerCase","expr1","_Parser$parseHelper","parseHelper","_Parser$parseHelper2","expr2","_Parser$parseHelper3","_Parser$parseHelper4","exprs","_Parser$parseHelper5","_Parser$parseHelper6","error","atom","_Parser$parseHelper7","_Parser$parseHelper8","ProofSequent","seqData","seqCalc","updateCalc","removeSequent","moveSequent","editSequent","finishSequent","renameSequent","_useState","useState","_useState2","textExpr","setTextExpr","_useState3","_useState4","textComment","setTextComment","_useState5","_useState6","setRule","moveMsg","checked","ids","idlist","assumumptionString","assumptions","defaultValue","canCheck","objectSpread","components_RuleSelector","valid","parsed","parse","newId","ProofList","updateData","src_components_ProofSequent","key","uuid","sc","colSpan","ExprAny","_a","Justification","_seqData","_seqCalc","size","add","_getSequent","_getSequent2","refData","refCalc","notElimPattern","notIntroCont","notIntroPattern","refAssumes","_getSequent5","_getSequent6","_getSequent7","_getSequent8","tmpCalc","refExprs","_getSequent9","_getSequent10","_loop","g","allQ","refIds","m","L","_expr","bipartiteMatch","_v","tmpExpr","tmpId","_getSequent11","_getSequent12","assumeList","_ret","_getSequent13","_getSequent14","_getSequent15","_getSequent16","r1data","r1calc","_getSequent17","_getSequent18","r2data","r2calc","ifElimPattern","_getSequent19","_getSequent20","ifIntroPattern","_getSequent21","_getSequent22","_getSequent23","_getSequent24","iffElimPattern","_getSequent25","_getSequent26","_getSequent27","_getSequent28","iffIntroPattern","r1assumes","r2assumes","i1","i2","_getSequent29","_getSequent30","contElimCont","contIntroCont","_getSequent31","_getSequent32","_getSequent33","_getSequent34","refsData","refsAssumes","anyInvalid","calc2","justifyAssume","justifyNotElim","justifyNotIntro","justifyAndElim","justifyAndIntro","justifyOrElim","justifyOrIntro","justifyIfElim","justifyIfIntro","justifyIffElim","justifyIffIntro","justifyContElim","justifyContIntro","justify","queue","App","setSeqData","Map","setSeqCalc","setEditing","onUnload","preventDefault","returnValue","cb","useEffect","addEventListener","removeEventListener","seq","newSeqCalc","newRefs","k","set","newSeqData","concat","toConsumableArray","slice","delete","justify_reachable","Fragment","src_components_Header","src_components_Menu","jsonData","JSON","program","filetype","version","proof","obj","expr_val","sequent","u","justify_all","sequents","Array","stringify","src_components_ProofList","sd","toUpdate","offset","calc1","oldId","oldCalc","src_components_Footer","ParserTestButton","reportWebVitals","onPerfEntry","Function","__webpack_require__","then","bind","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","src_App","getElementById"],"mappings":"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","file":"static/js/main.89ed2ca4.chunk.js","sourcesContent":["//export const APP_TITLE_LONG = \"Proof Interface for Sequent Systems\";\n//export const APP_TITLE_SHORT = \"PISS\";\nexport const APP_TITLE_LONG = \"Sequent Proof Interface Name\";\nexport const APP_TITLE_SHORT = \"SPIN\";\nexport const APP_TITLE_IS_TEMPORARY = false;\nexport const ENABLE_PARSER_TEST = false;\nexport const FOOTER_MESSAGE = \"Intermediate Logic Project by Thomas Kozlowski\";\n","import React, { ReactElement, FC } from \"react\";\nimport {FOOTER_MESSAGE} from \"../utils/Constants\";\nimport \"./Footer.css\";\n\ninterface Props {\n}\n\nconst Footer: FC<Props> = (): ReactElement => {\n    return (\n        <div className={\"footer\"}>\n            {FOOTER_MESSAGE}\n        </div>\n    );\n};\n\nexport default Footer;\n","import React, { ReactElement, FC } from \"react\";\nimport {APP_TITLE_IS_TEMPORARY, APP_TITLE_LONG,\n    APP_TITLE_SHORT} from \"../utils/Constants\";\nimport \"./Header.css\";\n\nconst Header: FC = (): ReactElement => {\n    return (\n        <div className={\"header\"}>\n            {APP_TITLE_LONG} ({APP_TITLE_SHORT})\n            {APP_TITLE_IS_TEMPORARY && \" (Temporary Name)\"}\n        </div>\n    );\n};\n\nexport default Header;\n","import React, { ReactElement, FC, useRef } from \"react\";\nimport {SequentData} from \"../logic/Sequent\";\nimport \"./Menu.css\";\n\ninterface Props {\n    addSequent: (s: SequentData) => boolean;\n    clearProof: () => void;\n    editing: string | null;\n    loadProofFile: (data: string) => boolean;\n    saveProofFile: () => string;\n}\n\nconst Menu: FC<Props> = ({addSequent, clearProof, editing,\n        loadProofFile, saveProofFile}: Props): ReactElement => {\n    const inputFile = useRef<HTMLInputElement>(null);\n    const openFile = () => {\n        if (inputFile.current)\n            inputFile.current.click();\n    };\n\n    return (\n        <div className={\"menu\"}>\n            <button onClick={() => openFile()}>\n                Open\n            </button>\n            { /* hidden input element to open a file */ }\n            <input type=\"file\" style={{display:\"none\"}} accept={\".spin,.json\"}\n                ref={inputFile} multiple={false} onChange={async e => {\n                    const files = e.target.files;\n                    if (files !== null && files.length > 0) {\n                        const data = await new Promise<string>(\n                                (resolve,reject) => {\n                            const reader = new FileReader();\n                            reader.onload = () => {\n                                if (!reader.result)\n                                    throw \"open: failure\";\n                                resolve(reader.result.toString());\n                            };\n                            reader.onabort = () => reject(\"open: failure\");\n                            reader.readAsText(files[0]);\n                        })\n                        try {\n                            if (!loadProofFile(data))\n                                alert(\"Proof file was not loaded.\");\n                        } catch (err) {\n                            alert(\"Error loading proof file: \"+err);\n                        }\n                    }\n                }} />\n            <button onClick={() => { // save\n                let fname = prompt(\"Enter a file name:\");\n                if (fname === null)\n                    return;\n                if (!fname.endsWith(\".spin\"))\n                    fname += \".spin\";\n                const data = saveProofFile();\n                const file = new Blob([data],{type:\"text/json\"});\n                const a = document.createElement(\"a\");\n                const url = URL.createObjectURL(file);\n                a.href = url;\n                a.download = fname;\n                document.body.appendChild(a);\n                a.click();\n                setTimeout(() => {\n                    document.body.removeChild(a);\n                    window.URL.revokeObjectURL(url);\n                });\n            }}>\n                Save\n            </button>\n            <button onClick={() => {\n                if (confirm(\"Reset the current proof?\"))\n                    clearProof();\n            }}>\n                New Proof\n            </button>\n            {/*\n            <button onClick={() => alert('not implemented')}>\n                Undo\n            </button>\n            <button onClick={() => alert('not implemented')}>\n                Redo\n            </button>\n            */}\n            <button onClick={() => {\n                const id = prompt(\"Enter ID:\");\n                if (id === null)\n                    return;\n                else if (id.length === 0)\n                    alert(\"ID cannot be empty.\");\n                else if (!id.match(/^[0-9A-Za-z_-]+$/))\n                    alert(\"ID can only contain letters, numbers, '_' and '-'.\");\n                else\n                    addSequent({\n                        comment: \"\",\n                        expr: null,\n                        expr_text: \"\",\n                        id: id,\n                        ref_by: new Set<string>(),\n                        refs: new Set<string>(),\n                        rule: \"\"\n                    });\n            }}>\n                New Sequent\n            </button>\n        </div>\n    );\n};\n\nexport default Menu;\n","import React, { ReactElement, FC, useState } from \"react\";\nimport {InferenceRule} from \"../utils/LogicUtils\";\n\ninterface Props {\n    enabled: boolean;\n    value: InferenceRule;\n    setValue: (rule: InferenceRule) => void;\n}\n\nconst RuleSelector: FC<Props> = ({enabled, value,\n        setValue}: Props): ReactElement => {\n    return (\n        <select disabled={!enabled} value={value}\n            onChange={e => setValue(e.target.value as InferenceRule)}>\n            <option value=\"\"></option>\n            <option value=\"assume\">Assume</option>\n            <option value=\"andE\">&and; Elim</option>\n            <option value=\"andI\">&and; Intro</option>\n            <option value=\"orE\">&or; Elim</option>\n            <option value=\"orI\">&or; Intro</option>\n            <option value=\"notE\">&not; Elim</option>\n            <option value=\"notI\">&not; Intro</option>\n            <option value=\"contE\">&perp; Elim</option>\n            <option value=\"contI\">&perp; Intro</option>\n            <option value=\"ifE\">&rarr; Elim</option>\n            <option value=\"ifI\">&rarr; Intro</option>\n            <option value=\"iffE\">&harr; Elim</option>\n            <option value=\"iffI\">&harr; Intro</option>\n        </select>\n    );\n};\n\nexport default RuleSelector;\n","import ExprBase from \"../logic/ExprBase\";\nimport {SequentCalc, SequentData} from \"../logic/Sequent\";\n\n/**\n * Specifies an inference rule (or none).\n */\ntype InferenceRule = \"\" | \"assume\" | \"notE\" | \"notI\" | \"andE\" | \"andI\"\n    | \"orE\" | \"orI\" | \"ifE\" | \"ifI\" | \"iffE\" | \"iffI\" | \"contE\" | \"contI\";\n\n/**\n * Atom names must start with a letter or _ and contain letters, _, and digits.\n */\nconst REGEX_ATOM = /[a-zA-z_][0-9a-zA-z_]*/;\n\nconst REGEX_ATOM_START = /[a-zA-z_]/;\n\nconst REGEX_WHITESPACE = /[ \\n\\t]*/;\n\nconst REGEX_NONWHITESPACE_CHAR = /[^ \\n\\t]/;\n\n/**\n * Compute a bipartite matching for the OR elim rule. The expressions from the\n * main OR must each go to a referencecd sequent having that expression in its\n * assumptions. Uses the Ford-Fulkerson algorithm.\n * \n * This code is partially based on the JavaScript pseudocode on GeeksforGeeks\n * https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/\n * https://www.geeksforgeeks.org/maximum-bipartite-matching/\n * \n * @param L expressions from the main OR\n * @param R referenced sequents to match to\n * @param data main data array\n * @param calc main calc array\n * @returns a maximum bipartite matching\n */\nconst bipartiteMatch = (L: ExprBase[], R: string[], data: SequentData[],\n        calc: Map<string,SequentCalc>): [ExprBase,string][] => {\n    // create bipartite graph, graph[i] is the elements of Y it can match to\n    const graph: Set<string>[] = [];\n    L.forEach(expr => { // make its possible match set\n        const ids = new Set<string>();\n        R.forEach(id => { // locate elements for the match set\n            const [_tmpData,tmpCalc] = getSequent(id,data,calc);\n            const index = indexOfSequent(expr, // find in assumptions\n                setToList(tmpCalc.assumptions),data,calc);\n            if (index !== -1)\n                ids.add(id);\n        });\n        graph.push(ids);\n    });\n    // track IDs in R matched to expressions in L by index, -1 if unmatched\n    const matchR: number[] = [];\n    R.forEach(() => matchR.push(-1)); // initially all unmatched\n    // DFS for each expr in L\n    L.forEach((_expr,i) => {\n        const seen: boolean[] = []; // the sequents in R \"seen\" by expr\n        R.forEach(() => seen.push(false));\n        bpdfs(graph,i,R,seen,matchR);\n    });\n    const ret: [ExprBase,string][] = [];\n    matchR.forEach((v,i) => {\n        if (v !== -1)\n            ret.push([L[v],R[i]]);\n    });\n    return ret;\n};\n\n/**\n * Helper function for bipartiteMatch(), performs the DFS search for an\n * augmenting path.\n * @param graph bipartite graph\n * @param i index of start vertex\n * @param seen vertices visited in R\n * @param matchR index in L matched to element in R\n */\nconst bpdfs = (graph: Set<string>[], i: number, R: string[],\n        seen: boolean[], matchR: number[]): boolean => {\n    for (let j = 0; j < matchR.length; ++j) {\n        // if L[i] can match to R[j] and R[j] not visited\n        if (!graph[i].has(R[j]) || seen[j])\n            continue;\n        seen[j] = true;\n        if (matchR[j] < 0 || bpdfs(graph,matchR[j],R,seen,matchR)) {\n            matchR[j] = i;\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Gets the data and calc objects for a sequent given the ID, assuming that no\n * errors will occur.\n * @param id sequent ID\n * @param data sequent data array\n * @param calc sequent calc array\n * @returns the data and calc objects for the desired sequent\n */\nconst getSequent = (id: string, data: SequentData[],\n        calc: Map<string,SequentCalc>): [SequentData,SequentCalc] => {\n    const idCalc = calc.get(id);\n    if (idCalc === undefined)\n        throw \"getSequent: invalid ID\";\n    return [data[idCalc.index],idCalc];\n};\n\n/**\n * Returns the smallest index of idList such that the sequent with that ID has\n * expr, or -1 if not found.\n * @param expr expression to find\n * @param idList list of sequent IDs to try\n * @param data main data array\n * @param calc main calc array\n */\nconst indexOfSequent = (expr: ExprBase, idList: string[], data: SequentData[],\n        calc: Map<string,SequentCalc>): number => {\n    for (let i = 0; i < idList.length; ++i) {\n        const [tmpData,_tmpCalc] = getSequent(idList[i],data,calc);\n        if (tmpData.expr === null)\n            throw \"indexOfSequent: internal error\";\n        if (expr.equals(tmpData.expr))\n            return i;\n    }\n    return -1;\n};\n\n/**\n * Find the index of an expression in a list.\n * @param expr expression to find\n * @param exprList list of expressions\n * @returns smallest index with expression equal to expr or -1 if not found\n */\nconst indexOfSequent2 = (expr: ExprBase, exprList: ExprBase[]): number => {\n    for (let i = 0; i < exprList.length; ++i)\n        if (expr.equals(exprList[i]))\n            return i;\n    return -1;\n};\n\n/**\n * Returns true if each list contains the same expressions, ignoring order.\n * @param a first list\n * @param b second list\n */\nconst sameExprs = (a: ExprBase[], b: ExprBase[]): boolean => {\n    if (a.length !== b.length)\n        return false;\n    const bMatched: boolean[] = [];\n    b.forEach(() => bMatched.push(false));\n    // for each element of a, set a true in bMatched\n    a.forEach(v => {\n        for (let i = 0; i < b.length; ++i)\n            if (!bMatched[i] && v.equals(b[i])) {\n                bMatched[i] = true;\n                break;\n            }\n    });\n    return bMatched.reduce((prev,curr) => prev && curr);\n};\n\n/**\n * Converts a set to a list.\n * @param s a set\n * @returns a list containing the elements in the set\n */\nconst setToList = <T>(s: Set<T>): T[] => {\n    const ret: T[] = [];\n    s.forEach(v => ret.push(v));\n    return ret;\n};\n\nexport type {InferenceRule};\n\nexport {REGEX_ATOM, REGEX_ATOM_START, REGEX_WHITESPACE,\n        REGEX_NONWHITESPACE_CHAR, bipartiteMatch, getSequent, setToList,\n        indexOfSequent, indexOfSequent2, sameExprs};\n","\n/**\n * Base class for propositional logic expressions.\n */\nabstract class ExprBase {\n    protected _values: ExprBase[];\n    constructor(values: ExprBase[]) {\n        this._values = values;\n    }\n    //abstract eval(): boolean;\n    get values() {\n        return this._values;\n    }\n\n    /**\n     * Convert to a string for display.\n     * @returns string representation\n     */\n    public abstract toString(): string;\n\n    /**\n     * Convert to a string for saving. This string can be parsed later.\n     * @returns string for saving the expression\n     */\n    public abstract toSaveString(): string;\n\n    /**\n     * Compares 2 logic expressions for value equality.\n     * @param a another logic expression\n     * @returns true if they are the same expression, false otherwise\n     */\n    public abstract equals(a: ExprBase): boolean;\n\n    /**\n     * Compare lists of expressions, requiring them to be in the same order.\n     * @param a expression list\n     * @param b expression list\n     * @returns true if the list have the same expressions in the same order\n     */\n    public static listsEqual(a: ExprBase[], b: ExprBase[]): boolean {\n        if (a.length !== b.length)\n            return false;\n        for (let i = 0; i < a.length; ++i)\n            if (!a[i].equals(b[i]))\n                return false;\n        return true;\n    }\n}\n\nexport default ExprBase;\n","import ExprBase from \"./ExprBase\";\n\n/**\n * Representation of the AND connective. Needs >= 2 expressions.\n */\nclass ExprAnd extends ExprBase {\n    constructor(a: ExprBase[]) {\n        if (a.length < 2)\n            throw \"AND must have >= 2 arguments\";\n        super(a);\n    }\n    public toString() {\n        return '(' + this.values.map(e => e.toString()).join(' \\u2227 ') + ')';\n    }\n    public toSaveString() {\n        return '(and ' + this.values.map(e => e.toSaveString()).join(' ') + ')';\n    }\n    public equals(a: ExprBase): boolean {\n        return (a instanceof ExprAnd)\n            && ExprBase.listsEqual(this.values,a.values);\n    }\n}\n\nexport default ExprAnd;\n","import {REGEX_ATOM} from \"../utils/LogicUtils\";\nimport ExprBase from \"./ExprBase\";\n\n/**\n * Representation of an atom (single variable).\n */\nclass ExprAtom extends ExprBase {\n    private _label: string;\n    constructor(a: string) {\n        super([]);\n        if (a.match(REGEX_ATOM))\n            this._label = a;\n        else\n            throw \"invalid atom\";\n    }\n    public toString() {\n        return this.label;\n    }\n    public toSaveString() {\n        return this.label;\n    }\n    get label() {\n        return this._label;\n    }\n    public equals(a: ExprBase): boolean {\n        return (a instanceof ExprAtom) && this.label === a.label;\n    }\n}\n\nexport default ExprAtom;\n","import ExprBase from \"./ExprBase\";\n\n/**\n * Representation of the contradiction symbol.\n */\nclass ExprCont extends ExprBase {\n    constructor() {\n        super([]);\n    }\n    public toString() {\n        return '\\u22a5';\n    }\n    public toSaveString() {\n        return '(cont)';\n    }\n    public equals(a: ExprBase): boolean {\n        return (a instanceof ExprCont);\n    }\n}\n\nexport default ExprCont;\n","import ExprBase from \"./ExprBase\";\n\n/**\n * Representation of the IF connective.\n */\nclass ExprIf extends ExprBase {\n    constructor(a: ExprBase, b: ExprBase) {\n        super([a,b]);\n    }\n    public toString() {\n        return '(' + this.values[0].toString() + ' \\u2192 '\n            + this.values[1].toString() + ')';\n    }\n    public toSaveString() {\n        return '(if ' + this.values[0].toSaveString() + ' '\n            + this.values[1].toSaveString() + ')';\n    }\n    public equals(a: ExprBase): boolean {\n        return (a instanceof ExprIf)\n            && ExprBase.listsEqual(this.values,a.values);\n    }\n}\n\nexport default ExprIf;\n","import ExprBase from \"./ExprBase\";\n\n/**\n * Representation of the IFF connective.\n */\nclass ExprIff extends ExprBase {\n    constructor(a: ExprBase, b: ExprBase) {\n        super([a,b]);\n    }\n    public toString() {\n        return '(' + this.values[0].toString() + ' \\u2194 '\n            + this.values[1].toString() + ')';\n    }\n    public toSaveString() {\n        return '(iff ' + this.values[0].toSaveString() + ' '\n            + this.values[1].toSaveString() + ')';\n    }\n    public equals(a: ExprBase): boolean {\n        return (a instanceof ExprIff)\n            && ExprBase.listsEqual(this.values,a.values);\n    }\n}\n\nexport default ExprIff;\n","import ExprBase from \"./ExprBase\";\n\n/**\n * Representation of the NOT operator.\n */\nclass ExprNot extends ExprBase {\n    constructor(a: ExprBase) {\n        super([a]);\n    }\n    public toString() {\n        return '\\u00ac' + this.values[0].toString();\n    }\n    public toSaveString() {\n        return '(not ' + this.values[0].toSaveString() + ')';\n    }\n    public equals(a: ExprBase): boolean {\n        return (a instanceof ExprNot)\n            && ExprBase.listsEqual(this.values,a.values);\n    }\n}\n\nexport default ExprNot;\n","import ExprBase from \"./ExprBase\";\n\n/**\n * Representation of the OR connective. Needs >= 2 expressions.\n */\nclass ExprOr extends ExprBase {\n    constructor(a: ExprBase[]) {\n        if (a.length < 2)\n            throw \"OR must have >= 2 arguments\";\n        super(a);\n    }\n    public toString() {\n        return '(' + this.values.map(e => e.toString()).join(' \\u2228 ') + ')';\n    }\n    public toSaveString() {\n        return '(or ' + this.values.map(e => e.toSaveString()).join(' ') + ')';\n    }\n    public equals(a: ExprBase): boolean {\n        return (a instanceof ExprOr)\n            && ExprBase.listsEqual(this.values,a.values);\n    }\n}\n\nexport default ExprOr;\n","import {REGEX_ATOM, REGEX_ATOM_START, REGEX_NONWHITESPACE_CHAR,\n    REGEX_WHITESPACE} from \"../utils/LogicUtils\";\nimport ExprAnd from \"./ExprAnd\";\nimport ExprAtom from \"./ExprAtom\";\nimport ExprBase from \"./ExprBase\";\nimport ExprCont from \"./ExprCont\";\nimport ExprIf from \"./ExprIf\";\nimport ExprIff from \"./ExprIff\";\nimport ExprNot from \"./ExprNot\";\nimport ExprOr from \"./ExprOr\";\n\nclass Parser {\n    private static skipWhitespace(a: string): string {\n        let whitespace = a.match(REGEX_WHITESPACE);\n        if (whitespace !== null)\n            a = a.substring(whitespace[0].length);\n        return a;\n    }\n\n    /**\n     * Parse part of an expression, extracting from the string.\n     * @param a the remaining string to parse\n     * @returns parsed expression and string after it\n     * @throws string describing the error if input is invalid\n     */\n    private static parseHelper(a: string): [ExprBase, string] {\n        let s = a;\n        // skip whitespace at start\n        s = Parser.skipWhitespace(s);\n        let char = s.match(REGEX_NONWHITESPACE_CHAR);\n        let expr = null;\n        if (char === null)\n            throw \"parseHelper: expected token or expression\";\n        if (char[0] === '(') { // parse connective\n            s = s.substring(1); // skip (\n            s = Parser.skipWhitespace(s);\n            let token = s.match(REGEX_ATOM);\n            // based on token, parse components\n            if (token === null)\n                throw \"parseHelper: expected connective name\";\n            s = s.substring(token[0].length);\n            if (token[0].toLowerCase() === 'cont') { // no arguments\n                expr = new ExprCont();\n            } else { // 1 argument\n                let expr1: ExprBase | null = null;\n                [expr1,s] = Parser.parseHelper(s);\n                if (token[0].toLowerCase() === 'not')\n                    expr = new ExprNot(expr1);\n                else { // 2 arguments\n                    let expr2: ExprBase | null = null;\n                    [expr2,s] = Parser.parseHelper(s);\n                    if (token[0].toLowerCase() === 'if')\n                        expr = new ExprIf(expr1,expr2);\n                    else if (token[0].toLowerCase() === 'iff')\n                        expr = new ExprIff(expr1,expr2);\n                    else { // variable length\n                        let exprs = [expr1,expr2];\n                        for (;;) {\n                            try {\n                                [expr1,s] = Parser.parseHelper(s);\n                            } catch (error) {\n                                break; // end when a parse fails\n                            }\n                            exprs.push(expr1);\n                        }\n                        if (token[0].toLowerCase() === 'and')\n                            expr = new ExprAnd(exprs);\n                        else if (token[0].toLowerCase() === 'or')\n                            expr = new ExprOr(exprs);\n                        else\n                            throw \"parseHelper: invalid connective name\";\n                    }\n                }\n            }\n            s = Parser.skipWhitespace(s);\n            char = s.match(REGEX_NONWHITESPACE_CHAR);\n            if (char === null || char[0] !== ')')\n                throw \"parseHelper: expected ')'\";\n            s = s.substring(1); // skip )\n        } else if (char[0].match(REGEX_ATOM_START)) { // parse atom\n            let atom = s.match(REGEX_ATOM);\n            if (atom === null) // will never happen\n                throw \"parseHelper: null atom error\";\n            expr = new ExprAtom(atom[0]);\n            s = s.substring(atom[0].length);\n        }\n        else\n            throw \"parseHelper: invalid token\";\n        s = Parser.skipWhitespace(s);\n        return [expr,s];\n    }\n\n    /**\n     * Parses a string into a logic expression. This parser uses the Lisp S\n     * expression style used by Slate.\n     * @param a string to parse\n     * @returns logic expression\n     * @throws string describing error if input is invalid\n     */\n    public static parse(a: string): ExprBase {\n        let [expr,s] = Parser.parseHelper(a);\n        if (s !== \"\")\n            throw \"parse: extra string data\";\n        return expr;\n    }\n}\n\nexport default Parser;\n","import React, { ReactElement, FC, useState } from \"react\";\nimport {SequentCalc, SequentData} from \"../logic/Sequent\";\nimport RuleSelector from \"./RuleSelector\";\nimport \"./ProofSequent.css\";\nimport Parser from \"../logic/Parser\";\nimport ExprBase from \"../logic/ExprBase\";\n\ninterface Props {\n    seqData: SequentData;\n    seqCalc: SequentCalc;\n    //updateData: (sd: SequentData) => void;\n    updateCalc: (sc: SequentCalc) => void;\n    removeSequent: (id: string) => boolean;\n    moveSequent: (id: string, offset: number) => boolean;\n    editing: string | null;\n    editSequent: (id: string) => boolean;\n    finishSequent: (id: string, seq: SequentData) => boolean;\n    renameSequent: (oldId: string, newId: string) => boolean;\n}\n\nconst ProofSequent: FC<Props> = ({seqData, seqCalc, updateCalc,\n        removeSequent, moveSequent, editing,\n        editSequent, finishSequent, renameSequent}: Props): ReactElement => {\n    // values entered into the text boxes\n    const [textExpr, setTextExpr] = useState(seqData.expr_text);\n    const [textComment, setTextComment] = useState(seqData.comment);\n    const [rule, setRule] = useState(seqData.rule);\n\n    const moveMsg = \"Sequents may only depend on previous sequents.\";\n\n    const assumumptionString = (ids: Set<string>): string => {\n        const idlist: string[] = [];\n        ids.forEach(s => idlist.push(s));\n        return idlist.join(\",\");\n    }\n\n    return (\n        <tr className={\"proofsequent\"\n                    + (editing === seqData.id ? \" proofediting\"\n                    : (seqCalc.checked ? \" seqselected\" : \"\"))}>\n            <td className=\"seqmove\">\n                <button disabled={editing !== null}\n                        onClick={() => {\n                            if (!moveSequent(seqData.id,-1))\n                                alert(moveMsg);\n                        }}>\n                    &and;\n                </button>\n                <button disabled={editing !== null}\n                        onClick={() => {\n                            if (!moveSequent(seqData.id,1))\n                                alert(moveMsg);\n                        }}>\n                    &or;\n                </button>\n            </td>\n            <td className=\"seqid\">{seqData.id}</td>\n            <td className=\"seqref\">\n                {\"{\"}{editing === seqData.id ? \"?\"\n                : assumumptionString(seqCalc.assumptions)}{\"}\"} &#8872;\n            </td>\n            <td className=\"seqexpr\">\n                {editing === seqData.id ?\n                    <textarea defaultValue={textExpr} onChange={e => {\n                        setTextExpr(e.target.value);\n                    }} />\n                : seqData.expr !== null ? seqData.expr.toString() :\n                    textExpr === \"\" ? \"<none>\" : \"<invalid>\" }\n            </td>\n            <td className=\"seqsel\">\n                <input type={\"checkbox\"} disabled={!seqCalc.canCheck}\n                    checked={seqCalc.checked}\n                    onChange={() => {\n                        updateCalc({\n                            ...seqCalc,\n                            checked: !seqCalc.checked\n                        });\n                    }} />\n            </td>\n            <td className=\"seqrule\">\n                <RuleSelector enabled={editing === seqData.id}\n                    value={rule} setValue={v => setRule(v)}/>\n            </td>\n            <td className={editing === seqData.id ? \"\" :\n                        (seqCalc.valid === true ? \"seqvalid\"\n                        : (seqCalc.valid === false ? \"seqinvalid\" : \"\"))}>\n            </td>\n            <td className=\"seqcomment\">\n                {editing === seqData.id ?\n                    <textarea defaultValue={textComment} onChange={e => {\n                        setTextComment(e.target.value);\n                    }} />\n                : seqData.comment }\n            </td>\n            <td className=\"seqactions\">\n                <button onClick={() => { // done/edit\n                    if (editing === seqData.id) {\n                        let parsed: null | ExprBase = null;\n                        try {\n                            parsed = Parser.parse(textExpr);\n                        } catch (error) {\n                            if (textExpr !== \"\")\n                                alert(\"Invalid expression: \"+error);\n                        }\n                        finishSequent(seqData.id,{\n                            ...seqData,\n                            comment: textComment,\n                            expr: parsed,\n                            expr_text: textExpr,\n                            rule: rule\n                            // finishSequent handles refs, ref_by\n                        });\n                    }\n                    else if (!editSequent(seqData.id))\n                        alert(\"Please finish editing current sequent.\");\n                    }}  className={editing === seqData.id ? \"donebutton\"\n                                                    : \"editbutton\"}\n                    disabled={editing !== null && editing !== seqData.id}>\n                    {editing === seqData.id ? \"Done\" : \"Edit\"}\n                </button>\n                <button disabled={editing !== null}\n                    onClick={() => {\n                        const newId = prompt(\"Enter new ID:\");\n                        if (newId === null)\n                            return;\n                        else if (newId.length === 0)\n                            alert(\"ID cannot be empty.\");\n                        else if (!newId.match(/^[0-9A-Za-z_-]+$/))\n                            alert(\"ID can only contain letters, numbers,\"\n                                    + \" '_' and '-'.\");\n                        else if (!renameSequent(seqData.id,newId))\n                            alert(\"Must use a new ID.\");\n                    }} className=\"renamebutton\">\n                    Rename\n                </button>\n                <button disabled={editing !== null}\n                    onClick={() => { // delete\n                    if (!confirm(\"Delete this sequent?\"))\n                        return;\n                    if (!removeSequent(seqData.id))\n                        alert(\"Error deleting sequent.\");\n                    }} className=\"deletebutton\">\n                    Delete\n                </button>\n            </td>\n        </tr>\n    );\n};\n\nexport default ProofSequent;\n","import React, { ReactElement, FC, useState } from \"react\";\nimport {SequentCalc, SequentData} from \"../logic/Sequent\";\nimport \"./ProofList.css\";\nimport ProofSequent from \"./ProofSequent\";\n\ninterface Props {\n    seqData: SequentData[];\n    seqCalc: Map<string,SequentCalc>;\n    updateData: (id: string, sd: SequentData) => void;\n    updateCalc: (id: string, sc: SequentCalc) => void;\n    removeSequent: (id: string) => boolean;\n    moveSequent: (id: string, offset: number) => boolean;\n    editing: string | null;\n    editSequent: (id: string) => boolean;\n    finishSequent: (id: string, seq: SequentData) => boolean;\n    renameSequent: (oldId: string, newId: string) => boolean;\n}\n\nconst ProofList: FC<Props> = ({seqData, seqCalc, updateData, updateCalc,\n        removeSequent, moveSequent, editing,\n        editSequent, finishSequent, renameSequent}: Props): ReactElement => {\n    return (\n        <table className={\"prooflist\"}>\n            <tbody>\n                <tr>\n                    <th>Move</th>\n                    <th>ID</th>\n                    <th>Assumptions</th>\n                    <th>Expression</th>\n                    <th>Select</th>\n                    <th>Rule</th>\n                    <th>Validity</th>\n                    <th>Comment</th>\n                    <th>Actions</th>\n                </tr>\n                {\n                    seqData.length > 0 ?\n                    seqData.map(s =>\n                        <ProofSequent key={seqCalc.get(s.id)!.uuid}\n                            seqData={s} seqCalc={seqCalc.get(s.id)!}\n                            //updateData={(sd) => updateData(s.id,sd)}\n                            updateCalc={(sc) => updateCalc(s.id,sc)}\n                            removeSequent={removeSequent}\n                            moveSequent={moveSequent} editing={editing}\n                            editSequent={editSequent}\n                            finishSequent={finishSequent}\n                            renameSequent={renameSequent} />)\n                    : <tr><td colSpan={9} className={\"nosequents\"}>\n                        No sequents added yet.</td></tr>\n                }\n            </tbody>\n        </table>\n    );\n};\n\nexport default ProofList;\n","import React, { ReactElement, FC } from \"react\";\nimport Parser from \"../logic/Parser\";\n\nconst Menu: FC = (): ReactElement => {\n    return (\n        <button onClick={() => {\n            let s = prompt(\"enter a string\");\n            if (s === null)\n                alert(\"you did not enter a string\");\n            else {\n                let e = null;\n                try {\n                    e = Parser.parse(s);\n                } catch (error) {\n                    alert(\"parsing error: \"+error);\n                }\n                if (e !== null)\n                    alert(e.toString() + '\\n' + e.toSaveString());\n            }\n        }}>\n            Test Parser\n        </button>\n    );\n};\n\nexport default Menu;\n","import ExprBase from \"./ExprBase\";\n\n/**\n * Representation for an expression that is allowed to match any expression.\n * This is used for pattern matching. The expression containing the ExprAny\n * type for matching must be the left operand:\n * - exprWithAny.equals(anotherExpr)\n */\nclass ExprAny extends ExprBase {\n    constructor() {\n        super([]);\n    }\n    public toString() {\n        return '*';\n    }\n    public toSaveString() {\n        return '(any)';\n    }\n    public equals(_a: ExprBase): boolean {\n        return true;\n    }\n}\n\nexport default ExprAny;\n","import {bipartiteMatch, getSequent, indexOfSequent, indexOfSequent2,\n    sameExprs, setToList} from \"../utils/LogicUtils\";\nimport ExprAnd from \"./ExprAnd\";\nimport ExprAny from \"./ExprAny\";\nimport ExprBase from \"./ExprBase\";\nimport ExprCont from \"./ExprCont\";\nimport ExprIf from \"./ExprIf\";\nimport ExprIff from \"./ExprIff\";\nimport ExprNot from \"./ExprNot\";\nimport ExprOr from \"./ExprOr\";\nimport {SequentCalc, SequentData} from \"./Sequent\";\n\nclass Justification {\n    // Individual justification functions assume referenced sequents are valid.\n    // They modify calc.assumptions and set calc.valid\n    // calc.assumptions starts as an empty set\n    // Comment in the form of: Seq1,Seq2,... -> NewSeq\n    // Sequents are written as {expr1,expr2,...}:=Expr\n\n    // -> {P}:=P (any P)\n    public static justifyAssume(data: SequentData, calc: SequentCalc,\n            _seqData: SequentData[], _seqCalc: Map<string,SequentCalc>): void {\n        if (data.refs.size > 0)\n            calc.valid = false;\n        else {\n            calc.assumptions.add(data.id);\n            calc.valid = true;\n        }\n    }\n\n    // G:=~~P -> G:=P (any P)\n    private static notElimPattern = new ExprNot(new ExprNot(new ExprAny()));\n    public static justifyNotElim(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 1)\n            calc.valid = false;\n        else { // pattern match the ref expr\n            const refs = setToList(data.refs);\n            const [refData,refCalc] = getSequent(refs[0],seqData,seqCalc);\n            if (refData.expr === null)\n                throw \"justifyNotElim: internal error\";\n            if (Justification.notElimPattern.equals(refData.expr)) {\n                const refInnerExpr = refData.expr.values[0].values[0];\n                if (refInnerExpr.equals(data.expr)) {\n                    calc.valid = true;\n                    // copy assumptions from ref expr\n                    refCalc.assumptions.forEach(s => calc.assumptions.add(s));\n                    return;\n                }\n            }\n            calc.valid = false;\n        }\n    }\n\n    // (G union {P}):=(cont) -> G:=(not P)\n    private static notIntroCont = new ExprCont();\n    private static notIntroPattern = new ExprNot(new ExprAny());\n    public static justifyNotIntro(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 1)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [refData,refCalc] = getSequent(refs[0],seqData,seqCalc);\n            if (refData.expr === null)\n                throw \"justifyNotIntro: internal error\";\n            // ref expr must be contradiction, match expr to not P\n            if (refData.expr.equals(Justification.notIntroCont)\n                && Justification.notIntroPattern.equals(data.expr)) {\n                const refAssumes = setToList(refCalc.assumptions);\n                const index = indexOfSequent(data.expr.values[0],refAssumes,\n                                                seqData,seqCalc);\n                if (index !== -1) {\n                    calc.valid = true;\n                    // copy assumptions except P\n                    refAssumes.forEach((v,i) => {\n                        if (i !== index)\n                            calc.assumptions.add(v);\n                    });\n                    return;\n                }\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G:=(and P1 P2 ...) -> G:=Pi (any Pi from P1,P2,...)\n    public static justifyAndElim(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 1)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [refData,refCalc] = getSequent(refs[0],seqData,seqCalc);\n            if (refData.expr === null)\n                throw \"justifyAndElim: internal error\";\n            if (refData.expr instanceof ExprAnd) {\n                const index = indexOfSequent2(data.expr,refData.expr.values);\n                if (index !== -1) { // found Pi in P1,P2,...\n                    calc.valid = true;\n                    refCalc.assumptions.forEach(s => calc.assumptions.add(s));\n                    return;\n                }\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G1:=P1, G2:=P2, ... -> (G1 union G2 union ...):=(and P1 P2 ...)\n    public static justifyAndIntro(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== data.expr.values.length\n            || !(data.expr instanceof ExprAnd))\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const refData: SequentData[] = [];\n            const refCalc: SequentCalc[] = [];\n            refs.forEach(s => { // get objects for referenced sequents\n                const [tmpData,tmpCalc] = getSequent(s,seqData,seqCalc);\n                refData.push(tmpData);\n                refCalc.push(tmpCalc);\n            });\n            const refExprs: ExprBase[] = [];\n            refData.forEach(v => {\n                if (v.expr === null)\n                    throw \"justifyAndIntro: internal error\";\n                refExprs.push(v.expr);\n            });\n            if (sameExprs(refExprs,data.expr.values)) {\n                calc.valid = true;\n                refCalc.forEach(v => {\n                    v.assumptions.forEach(s => calc.assumptions.add(s));\n                });\n                return;\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G:=(or P1 P2 ...), (G1 union {P1}):=Q, (G2 union {P2}):=Q, ...\n    // -> (G union G1 union G2 union ...):=Q\n    public static justifyOrElim(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const refData: SequentData[] = [];\n            const refCalc: SequentCalc[] = [];\n            const refExprs: ExprBase[] = [];\n            refs.forEach(s => { // get objects for referenced sequents\n                const [tmpData,tmpCalc] = getSequent(s,seqData,seqCalc);\n                refData.push(tmpData);\n                refCalc.push(tmpCalc);\n                if (tmpData.expr === null)\n                    throw \"justifyOrElim: internal error\";\n                refExprs.push(tmpData.expr);\n            });\n            for (let g = 0; g < refs.length; ++g) { // find main OR statement\n                if (!(refExprs[g] instanceof ExprOr))\n                    continue;\n                if (refExprs[g].values.length + 1 !== refExprs.length)\n                    continue; // must match each part of the OR to a sequent\n                // all other refs exprs must be Q\n                let allQ = true;\n                refExprs.forEach((v,i) => {\n                    if (data.expr === null)\n                        throw \"justifyOrElim: internal error\";\n                    if (i !== g && !data.expr.equals(v))\n                        allQ = false;\n                });\n                if (!allQ)\n                    continue;\n                // match main OR to assumptions of ref indexes i != g\n                const refIds: string[] = [];\n                refData.forEach((v,i) => {\n                    if (i !== g)\n                        refIds.push(v.id);\n                });\n                const m = bipartiteMatch(refExprs[g].values,refIds,\n                                            seqData,seqCalc);\n                if (m.length < refExprs[g].values.length)\n                    continue; // not all matched\n                m.forEach(v => { // set assumption set\n                    const [tmpExpr,tmpId] = v;\n                    const [_idData,idCalc] = getSequent(tmpId,seqData,seqCalc);\n                    const assumeList = setToList(idCalc.assumptions);\n                    const i = indexOfSequent(tmpExpr,\n                        assumeList,seqData,seqCalc);\n                    if (i === -1)\n                        throw \"justifyOrElim: internal error (index)\";\n                    // insert assumptions except for the matched expression\n                    assumeList.forEach((v,j) => {\n                        if (j !== i)\n                            calc.assumptions.add(v);\n                    });\n                });\n                refCalc[g].assumptions.forEach(s => calc.assumptions.add(s));\n                calc.valid = true;\n                return;\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G:=Pi -> G:=(or P1 P2 ...) (where Pi is in the P1,P2,...)\n    public static justifyOrIntro(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 1)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [refData,refCalc] = getSequent(refs[0],seqData,seqCalc);\n            if (refData.expr === null)\n                throw \"justifyOrIntro: internal error\";\n            if (data.expr instanceof ExprOr) {\n                const index = indexOfSequent2(refData.expr,data.expr.values);\n                if (index !== -1) {\n                    calc.valid = true;\n                    refCalc.assumptions.forEach(s => calc.assumptions.add(s));\n                    return;\n                }\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G1:=P, G2:=(if P Q) -> (G1 union G2):=Q (any P,Q)\n    private static ifElimPattern = new ExprIf(new ExprAny(), new ExprAny());\n    public static justifyIfElim(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 2)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [r1data,r1calc] = getSequent(refs[0],seqData,seqCalc);\n            const [r2data,r2calc] = getSequent(refs[1],seqData,seqCalc);\n            if (r1data.expr === null || r2data.expr === null)\n                throw \"justifyIfElim: internal error\";\n            if ((Justification.ifElimPattern.equals(r1data.expr)\n                && r1data.expr.values[0].equals(r2data.expr)\n                && r1data.expr.values[1].equals(data.expr))\n                || (Justification.ifElimPattern.equals(r2data.expr)\n                && r2data.expr.values[0].equals(r1data.expr)\n                && r2data.expr.values[1].equals(data.expr))) {\n                calc.valid = true;\n                r1calc.assumptions.forEach(s => calc.assumptions.add(s));\n                r2calc.assumptions.forEach(s => calc.assumptions.add(s));\n                return;\n            }\n            calc.valid = false;\n        }\n    }\n\n    // (G union {P}):=Q -> G:=(if P Q)\n    private static ifIntroPattern = new ExprIf(new ExprAny(), new ExprAny());\n    public static justifyIfIntro(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 1)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [refData,refCalc] = getSequent(refs[0],seqData,seqCalc);\n            if (refData.expr === null)\n                throw \"justifyIfIntro: internal error\";\n            if (Justification.ifIntroPattern.equals(data.expr)\n                && data.expr.values[1].equals(refData.expr)) {\n                const refAssumes = setToList(refCalc.assumptions);\n                const index = indexOfSequent(data.expr.values[0],refAssumes,\n                                                seqData,seqCalc);\n                if (index !== -1) {\n                    calc.valid = true;\n                    refAssumes.forEach((v,i) => {\n                        if (i !== index)\n                            calc.assumptions.add(v);\n                    });\n                    return;\n                }\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G1:=P, G2:=(iff P Q) -> (G1 union G2):=Q\n    private static iffElimPattern = new ExprIff(new ExprAny(), new ExprAny());\n    public static justifyIffElim(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 2)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [r1data,r1calc] = getSequent(refs[0],seqData,seqCalc);\n            const [r2data,r2calc] = getSequent(refs[1],seqData,seqCalc);\n            if (r1data.expr === null || r2data.expr === null)\n                throw \"justifyIffElim: internal error\";\n            if ((Justification.iffElimPattern.equals(r1data.expr)\n                && sameExprs(r1data.expr.values,[r2data.expr,data.expr]))\n                || (Justification.iffElimPattern.equals(r2data.expr)\n                && sameExprs(r2data.expr.values,[r1data.expr,data.expr]))) {\n                calc.valid = true;\n                r1calc.assumptions.forEach(s => calc.assumptions.add(s));\n                r2calc.assumptions.forEach(s => calc.assumptions.add(s));\n                return;\n            }\n            calc.valid = false;\n        }\n    }\n\n    // (G1 union {P}):=Q, (G2 union {Q}):=P -> (G1 union G2):=(iff P Q)\n    private static iffIntroPattern = new ExprIff(new ExprAny(), new ExprAny());\n    public static justifyIffIntro(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 2)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [r1data,r1calc] = getSequent(refs[0],seqData,seqCalc);\n            const [r2data,r2calc] = getSequent(refs[1],seqData,seqCalc);\n            if (r1data.expr === null || r2data.expr === null)\n                throw \"justifyIffIntro: internal error\";\n            if (Justification.iffIntroPattern.equals(data.expr)) {\n                const r1assumes = setToList(r1calc.assumptions);\n                const r2assumes = setToList(r2calc.assumptions);\n                let i1 = -1;\n                let i2 = -1;\n                if (data.expr.values[0].equals(r1data.expr)\n                    && data.expr.values[1].equals(r2data.expr)) {\n                    i1 = indexOfSequent(data.expr.values[1],\n                        r1assumes,seqData,seqCalc);\n                    i2 = indexOfSequent(data.expr.values[0],\n                        r2assumes,seqData,seqCalc);\n                }\n                if (data.expr.values[0].equals(r2data.expr)\n                    && data.expr.values[1].equals(r1data.expr)) {\n                    i1 = indexOfSequent(data.expr.values[0],\n                        r1assumes,seqData,seqCalc);\n                    i2 = indexOfSequent(data.expr.values[1],\n                        r2assumes,seqData,seqCalc);\n                }\n                if (i1 !== -1 && i2 !== -2) {\n                    calc.valid = true;\n                    r1assumes.forEach((v,i) => {\n                        if (i !== i1)\n                            calc.assumptions.add(v);\n                    });\n                    r2assumes.forEach((v,i) => {\n                        if (i !== i2)\n                            calc.assumptions.add(v);\n                    });\n                    return;\n                }\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G:=(cont) -> G:=P (any P)\n    private static contElimCont = new ExprCont();\n    public static justifyContElim(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.refs.size !== 1)\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [refData,refCalc] = getSequent(refs[0],seqData,seqCalc);\n            if (refData.expr === null)\n                throw \"justifyContElim: internal error\";\n            if (Justification.contElimCont.equals(refData.expr)) {\n                calc.valid = true;\n                refCalc.assumptions.forEach(s => calc.assumptions.add(s));\n                return;\n            }\n            calc.valid = false;\n        }\n    }\n\n    // G1:=P, G2:=(not P) -> (G1 union G2):=(cont) (any P)\n    private static contIntroCont = new ExprCont();\n    public static justifyContIntro(data: SequentData, calc: SequentCalc,\n            seqData: SequentData[], seqCalc: Map<string,SequentCalc>): void {\n        if (data.expr === null || data.refs.size !== 2\n            || !data.expr.equals(Justification.contIntroCont))\n            calc.valid = false;\n        else {\n            const refs = setToList(data.refs);\n            const [r1data,r1calc] = getSequent(refs[0],seqData,seqCalc);\n            const [r2data,r2calc] = getSequent(refs[1],seqData,seqCalc);\n            if (r1data.expr === null || r2data.expr === null)\n                throw \"justifyContIntro: internal error\";\n            // expressions are ~P,P in either order\n            if (r1data.expr.equals(new ExprNot(r2data.expr))\n                || r2data.expr.equals(new ExprNot(r1data.expr))) {\n                calc.valid = true;\n                r1calc.assumptions.forEach(s => calc.assumptions.add(s));\n                r2calc.assumptions.forEach(s => calc.assumptions.add(s));\n                return;\n            }\n            calc.valid = false;\n        }\n    }\n\n    /**\n     * Checks a sequent for correctness and modifies the data arrays as\n     * necessary.\n     * @param id sequent ID\n     * @param seqData main data array\n     * @param seqCalc main calc array\n     * @throws exception if an error occurs\n     */\n    public static justify(id: string, seqData: SequentData[],\n                        seqCalc: Map<string,SequentCalc>) {\n        const calc = seqCalc.get(id);\n        if (calc === undefined)\n            throw \"justify: nonexistent ID\";\n        const data = seqData[calc.index];\n        const refsData: SequentData[] = []; // list of the refs\n        const refsAssumes: Set<string>[] = [];\n        let anyInvalid = false; // check if any refs are not valid\n        data.refs.forEach(s => {\n            const calc2 = seqCalc.get(s);\n            if (calc2 === undefined)\n                throw \"justify: nonexistent ID\";\n            refsData.push(seqData[calc2.index]);\n            refsAssumes.push(calc2.assumptions);\n            if (!calc2.valid)\n                anyInvalid = true;\n        });\n        const expr = data.expr; // logic expression\n        calc.assumptions = new Set<string>(); // start with no assumptions\n        if (expr === null || anyInvalid) {\n            calc.valid = false;\n            return;\n        }\n        // all refs are valid, expr is not null\n        switch (data.rule) {\n            case \"\": // not justified\n                calc.valid = false;\n                break;\n            case \"assume\":\n                Justification.justifyAssume(data,calc,seqData,seqCalc);\n                break;\n            case \"notE\":\n                Justification.justifyNotElim(data,calc,seqData,seqCalc);\n                break;\n            case \"notI\":\n                Justification.justifyNotIntro(data,calc,seqData,seqCalc);\n                break;\n            case \"andE\":\n                Justification.justifyAndElim(data,calc,seqData,seqCalc);\n                break;\n            case \"andI\":\n                Justification.justifyAndIntro(data,calc,seqData,seqCalc);\n                break;\n            case \"orE\":\n                Justification.justifyOrElim(data,calc,seqData,seqCalc);\n                break;\n            case \"orI\":\n                Justification.justifyOrIntro(data,calc,seqData,seqCalc);\n                break;\n            case \"ifE\":\n                Justification.justifyIfElim(data,calc,seqData,seqCalc);\n                break;\n            case \"ifI\":\n                Justification.justifyIfIntro(data,calc,seqData,seqCalc);\n                break;\n            case \"iffE\":\n                Justification.justifyIffElim(data,calc,seqData,seqCalc);\n                break;\n            case \"iffI\":\n                Justification.justifyIffIntro(data,calc,seqData,seqCalc);\n                break;\n            case \"contE\":\n                Justification.justifyContElim(data,calc,seqData,seqCalc);\n                break;\n            case \"contI\":\n                Justification.justifyContIntro(data,calc,seqData,seqCalc);\n                break;\n            default: // will never happen\n                throw \"justify: invalid rule\";\n        }\n    }\n\n    /**\n     * Checks all sequents.\n     * @param data main data array\n     * @param calc main calc array\n     * @throws error if there is a problem justifying any sequent\n     */\n    public static justify_all(data: SequentData[],\n                        calc: Map<string,SequentCalc>) {\n        const ids: string[] = [];\n        data.forEach(v => ids.push(v.id));\n        ids.forEach(id => Justification.justify(id,data,calc));\n    }\n\n    /**\n     * Updates a root sequent and all those that depend on it.\n     * @param id root sequent ID\n     * @param data main data array\n     * @param calc main calc array\n     */\n    public static justify_reachable(id: string, data: SequentData[],\n                        calc: Map<string,SequentCalc>) {\n        const queue = [id];\n        let i = 0;\n        while (i < queue.length) {\n            Justification.justify(queue[i],data,calc);\n            const seqCalc = calc.get(queue[i]);\n            if (seqCalc === undefined)\n                throw \"justify_reachable: nonexistent sequent ID\";\n            data[seqCalc.index].ref_by.forEach(s => queue.push(s));\n            ++i;\n        }\n    }\n}\n\nexport default Justification;\n","import React, {useEffect, useRef, useState} from 'react';\nimport {v4 as uuid} from 'uuid';\nimport Footer from './components/Footer';\nimport Header from './components/Header';\nimport Menu from './components/Menu';\nimport ProofList from './components/ProofList';\nimport \"./App.css\";\nimport {SequentData, SequentCalc} from './logic/Sequent';\nimport {ENABLE_PARSER_TEST} from './utils/Constants';\nimport ParserTestButton from './components/ParserTestButton';\nimport Justification from './logic/Justification';\nimport {getSequent, InferenceRule, setToList} from './utils/LogicUtils';\nimport Parser from './logic/Parser';\nimport ExprBase from './logic/ExprBase';\n\nfunction App() {\n    // list of sequents representing the proof\n    const [seqData, setSeqData] = useState<SequentData[]>([]);\n    // list of extra data for sequents during runtime\n    const [seqCalc, setSeqCalc] = useState(new Map<string,SequentCalc>());\n    // which sequent is being edited or null\n    const [editing, setEditing] = useState<string | null>(null);\n\n    const onUnload = (e: BeforeUnloadEvent) => {\n        e.preventDefault();\n        e.returnValue = \"\";\n    };\n\n    const cb = useRef(onUnload);\n    useEffect(() => { cb.current = onUnload }, [onUnload]);\n    useEffect(() => {\n        window.addEventListener(\"beforeunload\",onUnload);\n        return () => window.removeEventListener(\"beforeunload\",onUnload);\n    },[]);\n\n    /**\n     * Resets the proof to a blank list.\n     */\n    const clearProof = (): void => {\n        setSeqData([]);\n        setSeqCalc(new Map<string,SequentCalc>());\n        setEditing(null);\n    };\n\n    /**\n     * Load a proof from file data. If an error occurs, throws an exception.\n     * @param data string representation of the file\n     * @returns true if file data was loaded, false otherwise\n     * @throws except if there is an error parsing the file data\n     */\n    const loadProofFile = (data: string): boolean => {\n        const jsonData = JSON.parse(data);\n        const program = jsonData[\"program\"] as string;\n        const filetype = jsonData[\"filetype\"] as string;\n        const version = jsonData[\"version\"] as number;\n        if (program !== \"spin\")\n            alert(\"Warning: program name data is incorrect\");\n        if (filetype !== \"sequent-propositional\")\n            alert(\"Warning: filetype data is not supported\");\n        if (version !== 1)\n            alert(\"Warning: file version is not supported\");\n        const proof = jsonData[\"proof\"][\"sequents\"] as any[];\n        const newSeqData: SequentData[] = [];\n        const newSeqCalc = new Map<string,SequentCalc>();\n        proof.forEach(obj => {\n            const id = obj[\"id\"] as string;\n            if (newSeqCalc.has(id))\n                throw \"loadProofFile: duplicate sequent ID found\";\n            const expr = obj[\"expr\"] as string;\n            let expr_val: null | ExprBase = null;\n            try {\n                if (expr !== \"\")\n                    expr_val = Parser.parse(expr);\n            } catch (err) {\n                throw \"loadProofFile: error parsing a sequent\";\n            }\n            const expr_text = obj[\"expr_text\"] as string;\n            const rule = obj[\"rule\"] as string as InferenceRule;\n            const refs = obj[\"refs\"] as any[];\n            const comment = obj[\"comment\"] as string;\n            const sequent: SequentData = {\n                comment: comment,\n                expr: expr_val,\n                expr_text: expr_text,\n                id: id,\n                ref_by: new Set<string>(),\n                refs: new Set<string>(),\n                rule: rule\n            };\n            refs.forEach(u => {\n                const v = u as string;\n                if (!newSeqCalc.has(v))\n                    throw \"loadProofFile: sequent has invalid reference\";\n                sequent.refs.add(v);\n            });\n            newSeqCalc.set(id,{\n                assumptions: new Set<string>(),\n                canCheck: false,\n                checked: false,\n                index: newSeqData.length,\n                valid: false,\n                uuid: uuid()\n            });\n            newSeqData.push(sequent);\n        });\n        newSeqData.forEach(v => { // set ref_by\n            v.refs.forEach(s => {\n                const [tmpData,_tmpCalc] = getSequent(s,newSeqData,newSeqCalc);\n                tmpData.ref_by.add(v.id);\n            });\n        });\n        Justification.justify_all(newSeqData,newSeqCalc);\n        clearProof();\n        setSeqCalc(newSeqCalc);\n        setSeqData(newSeqData);\n        return true;\n    };\n\n    /**\n     * Returns a string representation of the current proof.\n     */\n    const saveProofFile = (): string => {\n        const data = {\n            program: \"spin\",\n            filetype: \"sequent-propositional\",\n            version: 1,\n            proof: {\n                sequents: new Array<any>()\n            }\n        };\n        seqData.forEach(seq => {\n            data.proof.sequents.push({\n                id: seq.id,\n                expr: seq.expr === null ? \"\" : seq.expr.toSaveString(),\n                expr_text: seq.expr_text,\n                rule: seq.rule as string,\n                refs: setToList(seq.refs),\n                comment: seq.comment\n            });\n        });\n        return JSON.stringify(data);\n    };\n\n    /**\n     * Rename a sequent.\n     * @param oldId existing sequent ID\n     * @param newId new sequent ID\n     * @returns true if the rename was successful\n     */\n    const renameSequent = (oldId: string, newId: string): boolean => {\n        if (editing !== null || seqCalc.has(newId) || !seqCalc.has(oldId))\n            return false;\n        const [_oldData,oldCalc] = getSequent(oldId,seqData,seqCalc);\n        const newSeqData = [...seqData];\n        const newSeqCalc = new Map<string,SequentCalc>();\n        seqCalc.forEach((v,k) => newSeqCalc.set(k,v));\n        newSeqCalc.set(newId,oldCalc);\n        newSeqCalc.delete(oldId);\n        newSeqCalc.forEach(v => {\n            if (v.assumptions.has(oldId)) {\n                v.assumptions.delete(oldId);\n                v.assumptions.add(newId);\n            }\n        });\n        newSeqData.forEach(v => {\n            if (v.id === oldId)\n                v.id = newId;\n            if (v.ref_by.has(oldId)) {\n                v.ref_by.delete(oldId);\n                v.ref_by.add(newId);\n            }\n            if (v.refs.has(oldId)) {\n                v.refs.delete(oldId);\n                v.refs.add(newId);\n            }\n        });\n        setSeqData(newSeqData);\n        setSeqCalc(newSeqCalc);\n        return true;\n    }\n\n    /**\n     * Sets the sequent to editing, only when no sequent is currently editing.\n     * @param id sequent ID\n     * @returns true if set to editing\n     */\n    const editSequent = (id: string): boolean => {\n        if (editing !== null)\n            return false;\n        const [data,calc] = getSequent(id,seqData,seqCalc);\n        const newSeqCalc = new Map<string,SequentCalc>();\n        seqCalc.forEach((v,k) => {\n            newSeqCalc.set(k,{\n                ...v,\n                canCheck: v.index < calc.index,\n                checked: data.refs.has(k)\n            });\n        });\n        setSeqCalc(newSeqCalc);\n        setEditing(id);\n        return true;\n    };\n\n    /**\n     * Sets the sequent to done, only when it is currently editing. This\n     * function handles calculating some of the properties.\n     * @param id sequent ID\n     * @param seq new sequent data\n     * @returns true if set to done\n     */\n    const finishSequent = (id: string, seq: SequentData): boolean => {\n        if (editing !== id)\n            return false;\n        const [_data,calc] = getSequent(id,seqData,seqCalc);\n        const newSeqCalc = new Map<string,SequentCalc>();\n        const newRefs = new Set<string>();\n        seqCalc.forEach((v,k) => {\n            if (v.checked)\n                newRefs.add(k);\n            newSeqCalc.set(k,{\n                ...v,\n                canCheck: false,\n                checked: false\n            });\n        });\n        let newSeqData = [...seqData.slice(0,calc.index),\n                    {\n                        ...seq,\n                        refs: newRefs\n                    },...seqData.slice(calc.index+1)];\n        newSeqData.forEach(v => { // update ref_by\n            if (newRefs.has(v.id))\n                v.ref_by.add(id);\n            else\n                v.ref_by.delete(id);\n        });\n        Justification.justify_reachable(id,newSeqData,newSeqCalc);\n        setSeqData(newSeqData);\n        setSeqCalc(newSeqCalc);\n        setEditing(null);\n        return true;\n    };\n\n    /**\n     * Replace data for a sequent in the state.\n     * @param id sequent ID\n     * @param sd sequent data\n     */\n    const updateData = (id: string, sd: SequentData): void => {\n        const newSeqData = [...seqData];\n        const [_data,calc] = getSequent(id,seqData,seqCalc);\n        newSeqData[calc.index] = sd;\n        setSeqData(newSeqData);\n    };\n\n    /**\n     * Replace calculated data for a sequent in the state.\n     * @param id sequent ID\n     * @param sc sequent calculated data\n     */\n    const updateCalc = (id: string, sc: SequentCalc): void => {\n        const newSeqCalc = new Map<string,SequentCalc>();\n        seqCalc.forEach((v,k) => newSeqCalc.set(k,v));\n        newSeqCalc.set(id,sc);\n        setSeqCalc(newSeqCalc);\n    }\n\n    /**\n     * Adds a sequent to the end of the proof list.\n     * @param s sequent object\n     * @returns true if added successfully, null if currently in edit mode\n     */\n    const addSequent = (s: SequentData): boolean => {\n        if (seqCalc.has(s.id))\n            alert(\"Sequent with this ID already exists.\");\n        else {\n            updateCalc(s.id,{\n                assumptions: new Set<string>(),\n                canCheck: false,\n                checked: false,\n                index: seqData.length,\n                valid: false,\n                uuid: uuid()\n            });\n            setSeqData([...seqData,s]);\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Removes a sequent from the proof list.\n     * @param id id of the sequent to remove\n     * @returns true if removed successfully\n     */\n    const removeSequent = (id: string): boolean => {\n        const calc = seqCalc.get(id);\n        if (calc === undefined)\n            return false;\n        if (editing === id)\n            finishSequent(id,seqData[calc.index]);\n        const toUpdate = seqData[calc.index].ref_by;\n        const newSeqData = [...seqData.slice(0,calc.index),\n                        ...seqData.slice(calc.index+1)];\n        const newSeqCalc = new Map<string,SequentCalc>();\n        seqCalc.forEach((v,k) => newSeqCalc.set(k,v));\n        newSeqCalc.delete(id);\n        newSeqData.forEach((v,i) => {\n            const calc2 = newSeqCalc.get(v.id);\n            if (calc2 === undefined) // should never happen\n                throw \"removeSequent: internal error\";\n            newSeqCalc.set(v.id,{\n                ...calc2,\n                index: i\n            });\n            v.refs.delete(id);\n            v.ref_by.delete(id);\n        });\n        toUpdate.forEach(s =>\n            Justification.justify_reachable(s,newSeqData,newSeqCalc));\n        setSeqData(newSeqData);\n        setSeqCalc(newSeqCalc);\n        return true;\n    };\n\n    /**\n     * Swaps order of 2 sequents. This is meant to move a sequent up/down.\n     * Returns false if reordering would make a sequent depend on a later one.\n     * @param id id of the sequent\n     * @param offset offset of sequent to swap with (must be -1 or 1)\n     * @returns false if swap is not allowed\n     */\n    const moveSequent = (id: string, offset: number): boolean => {\n        const calc1 = seqCalc.get(id);\n        if (calc1 === undefined)\n            return true;\n        const i = calc1.index - (offset === 1 ? 0 : 1); // lower index\n        if (i === -1 || i === seqData.length-1)\n            return true;\n        if (seqData[i+1].refs.has(seqData[i].id)) // swap not allowed\n            return false;\n        const newSeqCalc = new Map<string,SequentCalc>();\n        seqCalc.forEach((v,k) => {\n            if (v.index === i)\n                newSeqCalc.set(k,{...v,index:i+1})\n            else if (v.index === i+1)\n                newSeqCalc.set(k,{...v,index:i});\n            else\n                newSeqCalc.set(k,v);\n        });\n        const newSeqData = [...seqData.slice(0,i),seqData[i+1],\n                    seqData[i],...seqData.slice(i+2)];\n        setSeqData(newSeqData);\n        setSeqCalc(newSeqCalc);\n        return true;\n    };\n\n    return (\n        <>\n            <Header />\n            <Menu addSequent={addSequent} clearProof={clearProof}\n                loadProofFile={loadProofFile} saveProofFile={saveProofFile}\n                editing={editing} />\n            <ProofList seqData={seqData} seqCalc={seqCalc}\n                updateData={updateData} updateCalc={updateCalc}\n                removeSequent={removeSequent} moveSequent={moveSequent}\n                editing={editing} editSequent={editSequent}\n                finishSequent={finishSequent} renameSequent={renameSequent} />\n            <Footer />\n            {ENABLE_PARSER_TEST && <ParserTestButton />}\n        </>\n    );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}